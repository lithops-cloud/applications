{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About","title":"Home"},{"location":"getting-started/","text":"Welcome to MkDocs \u00b6 For full documentation visit mkdocs.org . Commands \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout \u00b6 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Getting started"},{"location":"getting-started/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"getting-started/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"getting-started/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"moments-in-time/","text":"import os import io import time from torch import save , load import torch.optim import torch.nn.parallel from torch.nn import functional as F import models from utils import extract_frames , load_frames , render_frames from cloudbutton import Pool , CloudStorage ROOT_URL = 'http://moments.csail.mit.edu/moments_models' WEIGHT_FILE = 'moments_RGB_resnet50_imagenetpretrained.pth.tar' NUM_SEGMENTS = 16 IMAGES_BUCKET_DIR = 'momentsintime/images' # input images storage prefix MODEL_BUCKET_KEY = 'momentsintime/models/moments_RGB_resnet50_imagenetpretrained' if not os . access ( WEIGHT_FILE , os . W_OK ): os . system ( 'wget ' + '/' . join ( ROOT_URL , WEIGHT_FILE )) # Load pretrained resnet50 model model = models . load_model ( WEIGHT_FILE ) buf = io . BytesIO () torch . save ( model , buf ) # Save model to cloud storage cloud_storage = CloudStorage () cloud_storage . put_data ( key = MODEL_BUCKET_KEY , data = buf ) def predict_video ( categories , transform , cloud_storage , video_key ): start = time . time () model_bytes = cloud_storage . get_data ( MODEL_BUCKET_KEY ) model = torch . load ( io . BytesIO ( model_bytes )) print ( 'Time to get the model:' , round ( time . time () - start , 3 )) model . eval () # Obtain video frames start = time . time () video_bytes = cloud_storage . get_data ( video_key ) print ( 'Time to get the video:' , round ( time . time () - start , 3 )) local_video_key = '/tmp/image_to_predict.mp4' with open ( local_video_key , 'wb' ) as f : f . write ( video_bytes ) frames = extract_frames ( local_video_key , NUM_SEGMENTS ) os . remove ( local_video_key ) # Prepare input tensor [num_frames, 3, 224, 224] input = torch . stack ([ transform ( frame ) for frame in frames ]) # Make video prediction with torch . no_grad (): logits = model ( input ) h_x = F . softmax ( logits , 1 ) . mean ( dim = 0 ) probs , idx = h_x . sort ( 0 , True ) # Output the prediction output = {} for i in range ( 0 , 5 ): output [ categories [ idx [ i ]]] = round ( float ( probs [ i ]), 5 ) return output video_keys = cs . list_tmp_data ( prefix = IMAGES_BUCKET_DIR ) print ( video_keys [: 10 ]) # Get dataset categories categories = models . load_categories () # Load the video frame transform transform = models . load_transform () with Pool () as pool : iterable = [( categories , transform , cs , k ) for k in video_keys ] res = pool . map_async ( func = predict_video , iterable = iterable ) print ( res . get ())","title":"Moments in time"},{"location":"examples/mandelbrot_set/","text":"from pw_mandelbrot import mandelbrot_image , create_subplots width = height = 512 maxiter = 60 concurrency = 1024 # number of functions executed in parallel % matplotlib notebook xtarget = - 0.7436438870 ytarget = 0.1318259042 # Initial rectangle position delta = 1 xmin = xtarget - delta xmax = xtarget + delta ymin = ytarget - delta ymax = ytarget + delta subplots = create_subplots ( width , height ) mandelbrot_image ( xmin , xmax , ymin , ymax , width , height , maxiter , concurrency , subplots ) # 1st zoom delta = 0.4 xmin = xtarget - delta xmax = xtarget + delta ymin = ytarget - delta ymax = ytarget + delta mandelbrot_image ( xmin , xmax , ymin , ymax , width , height , maxiter , concurrency , subplots ) # 2nd zoom delta = delta * 0.4 xmin = xtarget - delta xmax = xtarget + delta ymin = ytarget - delta ymax = ytarget + delta maxiter += 30 mandelbrot_image ( xmin , xmax , ymin , ymax , width , height , maxiter , concurrency , subplots ) # 3rd zoom delta = delta * 0.4 xmin = xtarget - delta xmax = xtarget + delta ymin = ytarget - delta ymax = ytarget + delta maxiter += 30 mandelbrot_image ( xmin , xmax , ymin , ymax , width , height , maxiter , concurrency , subplots ) # 4th zoom delta = delta * 0.4 xmin = xtarget - delta xmax = xtarget + delta ymin = ytarget - delta ymax = ytarget + delta maxiter += 40 mandelbrot_image ( xmin , xmax , ymin , ymax , width , height , maxiter , concurrency , subplots ) # 5th zoom delta = delta * 0.4 xmin = xtarget - delta xmax = xtarget + delta ymin = ytarget - delta ymax = ytarget + delta maxiter += 40 mandelbrot_image ( xmin , xmax , ymin , ymax , width , height , maxiter , concurrency , subplots ) # 6th zoom delta = delta * 0.4 xmin = xtarget - delta xmax = xtarget + delta ymin = ytarget - delta ymax = ytarget + delta maxiter = 500 mandelbrot_image ( xmin , xmax , ymin , ymax , width , height , maxiter , concurrency , subplots ) <IPython.core.display.Javascript object> PyWren v1.0.21-SNAPSHOT init for IBM Cloud Functions - Namespace: cloudlab_urv_us_east - Region: us_east ExecutorID db77-4135 | JobID M000 - Selected Runtime: ibmfunctions/action-python-v3.6 - 256MB ExecutorID db77-4135 | JobID M000 - Uploading function and data - Total: 1.9KiB ExecutorID db77-4135 | JobID M000 - Starting function invocation: mandelbrot_chunk_fn() - Total: 1024 activations PyWren v1.0.21-SNAPSHOT init for IBM Cloud Functions - Namespace: cloudlab_urv_us_east - Region: us_east ExecutorID 2654-4057 | JobID M000 - Selected Runtime: ibmfunctions/action-python-v3.6 - 256MB ExecutorID 2654-4057 | JobID M000 - Uploading function and data - Total: 1.9KiB ExecutorID 2654-4057 | JobID M000 - Starting function invocation: mandelbrot_chunk_fn() - Total: 1024 activations PyWren v1.0.21-SNAPSHOT init for IBM Cloud Functions - Namespace: cloudlab_urv_us_east - Region: us_east ExecutorID fa27-48fe | JobID M000 - Selected Runtime: ibmfunctions/action-python-v3.6 - 256MB ExecutorID fa27-48fe | JobID M000 - Uploading function and data - Total: 1.9KiB ExecutorID fa27-48fe | JobID M000 - Starting function invocation: mandelbrot_chunk_fn() - Total: 1024 activations PyWren v1.0.21-SNAPSHOT init for IBM Cloud Functions - Namespace: cloudlab_urv_us_east - Region: us_east ExecutorID 863a-4c46 | JobID M000 - Selected Runtime: ibmfunctions/action-python-v3.6 - 256MB ExecutorID 863a-4c46 | JobID M000 - Uploading function and data - Total: 1.9KiB ExecutorID 863a-4c46 | JobID M000 - Starting function invocation: mandelbrot_chunk_fn() - Total: 1024 activations PyWren v1.0.21-SNAPSHOT init for IBM Cloud Functions - Namespace: cloudlab_urv_us_east - Region: us_east ExecutorID 1fc0-4078 | JobID M000 - Selected Runtime: ibmfunctions/action-python-v3.6 - 256MB ExecutorID 1fc0-4078 | JobID M000 - Uploading function and data - Total: 1.9KiB ExecutorID 1fc0-4078 | JobID M000 - Starting function invocation: mandelbrot_chunk_fn() - Total: 1024 activations PyWren v1.0.21-SNAPSHOT init for IBM Cloud Functions - Namespace: cloudlab_urv_us_east - Region: us_east ExecutorID 66bc-4843 | JobID M000 - Selected Runtime: ibmfunctions/action-python-v3.6 - 256MB ExecutorID 66bc-4843 | JobID M000 - Uploading function and data - Total: 1.9KiB ExecutorID 66bc-4843 | JobID M000 - Starting function invocation: mandelbrot_chunk_fn() - Total: 1024 activations PyWren v1.0.21-SNAPSHOT init for IBM Cloud Functions - Namespace: cloudlab_urv_us_east - Region: us_east ExecutorID c944-489f | JobID M000 - Selected Runtime: ibmfunctions/action-python-v3.6 - 256MB ExecutorID c944-489f | JobID M000 - Uploading function and data - Total: 1.9KiB ExecutorID c944-489f | JobID M000 - Starting function invocation: mandelbrot_chunk_fn() - Total: 1024 activations","title":"Mandelbrot set"},{"location":"examples/pi_montecarlo/","text":"import numpy as np import os import pywren_ibm_cloud as pywren import pickle import matplotlib.pyplot as plt import pika import yaml % matplotlib notebook n_functs = 1000 loop_per_funct = 10000 iter_send_point = 50 points_sent_len = 100 n_maps = 3 with open ( 'config.yaml' ) as conff : config = yaml . safe_load ( conff ) rabbitmq_url = config [ 'amqp_url' ] rabbitmq_queue = 'pi_montecarlo' def pi_montecarlo ( n , rabbitmq ): channel = rabbitmq . channel () channel . queue_declare ( queue = rabbitmq_queue , auto_delete = True ) l = list () value = 0 sent = False funct_status = ( n % iter_send_point == 0 ) for i in range ( loop_per_funct ): x = np . random . rand () # Generate random point between 0 and 1 y = np . random . rand () z = np . sqrt ( x * x + y * y ) if z <= 1 : # Point is inside circle value += 1 if funct_status : l . append (( x , y , z )) if ( not sent and funct_status and len ( l ) == points_sent_len ): # Send generated point sent = True body = pickle . dumps ( l ) channel . basic_publish ( exchange = '' , routing_key = 'pi_montecarlo' , body = body ) est_pi = float ( value ) * 4 / loop_per_funct return est_pi def mean ( results ): return np . mean ( results ) pwex = pywren . ibm_cf_executor ( runtime_memory = 256 , rabbitmq_monitor = True ) map_iterdata = range ( n_functs ) for i in range ( n_maps ): pwex . map_reduce ( pi_montecarlo , map_iterdata , mean ) PyWren v1.0.21-SNAPSHOT init for IBM Cloud Functions - Namespace: cloudlab_urv_us_east - Region: us_east ExecutorID 95c7-496c | JobID M000 - Selected Runtime: ibmfunctions/action-python-v3.7 - 256MB ExecutorID 95c7-496c | JobID M000 - Uploading function and data - Total: 22.4KiB ExecutorID 95c7-496c | JobID M000 - Starting function invocation: pi_montecarlo() - Total: 1000 activations ExecutorID 95c7-496c | JobID R000 - Selected Runtime: ibmfunctions/action-python-v3.7 - 256MB ExecutorID 95c7-496c | JobID R000 - Uploading function and data - Total: 357.3KiB ExecutorID 95c7-496c | JobID R000 - Starting function invocation: mean() - Total: 1 activations ExecutorID 95c7-496c | JobID M002 - Selected Runtime: ibmfunctions/action-python-v3.7 - 256MB ExecutorID 95c7-496c | JobID M002 - Uploading function and data - Total: 22.4KiB ExecutorID 95c7-496c | JobID M002 - Starting function invocation: pi_montecarlo() - Total: 1000 activations ExecutorID 95c7-496c | JobID R002 - Selected Runtime: ibmfunctions/action-python-v3.7 - 256MB ExecutorID 95c7-496c | JobID R002 - Uploading function and data - Total: 357.3KiB ExecutorID 95c7-496c | JobID R002 - Starting function invocation: mean() - Total: 1 activations ExecutorID 95c7-496c | JobID M004 - Selected Runtime: ibmfunctions/action-python-v3.7 - 256MB ExecutorID 95c7-496c | JobID M004 - Uploading function and data - Total: 22.4KiB ExecutorID 95c7-496c | JobID M004 - Starting function invocation: pi_montecarlo() - Total: 1000 activations ExecutorID 95c7-496c | JobID R004 - Selected Runtime: ibmfunctions/action-python-v3.7 - 256MB ExecutorID 95c7-496c | JobID R004 - Uploading function and data - Total: 357.3KiB ExecutorID 95c7-496c | JobID R004 - Starting function invocation: mean() - Total: 1 activations params = pika . URLParameters ( rabbitmq_url ) connection = pika . BlockingConnection ( params ) channel = connection . channel () channel . queue_declare ( queue = rabbitmq_queue , auto_delete = True ) fig , ax = plt . subplots ( figsize = ( 7.5 , 7.5 )) plt . ion () fig . canvas . draw () plt . show () class callback (): def __init__ ( self ): self . n_messages = 0 def __call__ ( self , ch , method , properties , body ): l = pickle . loads ( body ) for x , y , z in l : color = 'red' if z <= 1 else 'blue' ax . scatter ( x , y , c = color , s = 2 ) self . n_messages += 1 plt . title ( \"Displaying {} of {} generated points\" . format ( self . n_messages * points_sent_len , n_functs * loop_per_funct * n_maps )) fig . canvas . draw () if self . n_messages >= (( n_functs * n_maps ) // iter_send_point ): ch . stop_consuming () channel . basic_consume ( callback (), queue = 'pi_montecarlo' ) channel . start_consuming () channel . queue_delete ( queue = rabbitmq_queue ) connection . close () plt . close () <IPython.core.display.Javascript object> results = pwex . get_result () est_pi = np . mean ( results ) print ( 'Estimated pi: {} ' . format ( est_pi )) pwex . clean () ExecutorID 95c7-496c - Getting results... HBox(children=(IntProgress(value=0, max=3003), HTML(value=''))) Estimated pi: 3.140845333333333 ExecutorID 95c7-496c - Cleaning temporary data","title":"Pi montecarlo"}]}